
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Linear Interpolation (functions)</title><meta name="generator" content="MATLAB 7.11.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-05-29"><meta name="DC.source" content="bsLinearInterpolation.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Linear Interpolation (functions)</h1><!--introduction--><p><b>The class contains a number of linear interpolation functions which are intended, specifically, to give the user more functionality concerning extrapolation than is provided by the standard MatLab library.</b></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">How to use the class</a></li><li><a href="#4">Properties</a></li><li><a href="#6">List of methods</a></li><li><a href="#9">Details of methods</a></li></ul></div><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">classdef</span> bsLinearInterpolation
</pre><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>How to use the class<a name="3"></a></h2><p>There are two ways to use the class:</p><div><ol><li>To produce an array (whether it be an <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix, a vector or just a single value) of points interpolated from a raw data object, using linear interpolation in rows.</li><li>To produce an array (whether it be an <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix, a vector or just a single value) of points interpolated from a two dimensional raw data object, using bilinear interpolation.</li></ol></div><h2>Properties<a name="4"></a></h2><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    properties
    <span class="keyword">end</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>List of methods<a name="6"></a></h2><p>The class introduces seven new methods:</p><p><b>1) <tt>[LinearMatrix()]</tt></b> : Function returns a matrix of interpolated values found using linear interpolation on a raw data set.</p><p><b>2) <tt>[LinearArray()]</tt></b> : Function returns a row vector of interpolated values found using linear interpolation on a raw data set.</p><p><b>3) <tt>[LinearArraySearch()]</tt></b> : Function returns a single interpolated value found using linear interpolation on a raw data set. The function finds the raw data points used for the interpolation from the raw data# set.</p><p><b>4) <tt>[LinearInterpolation()]</tt></b> : Function returns a single interpolated value. This is calculated through linear interpolation, using the points (<b><tt>F1</tt></b>, <b><tt>X1</tt></b>) and (<b><tt>F2</tt></b>, <b><tt>X2</tt></b>), which are inputs of the function.</p><p><b>5) <tt>[BiLinearInterpolation()]</tt></b> : Function returns a single interpolated value, specified by the point (<b><tt>x</tt></b>, <b><tt>y</tt></b>), using bilinear interpolation from the four input points.</p><p><b>6) <tt>[BiLinearMatrix()]</tt></b> : Function returns a matrix of bilinearly interpolated values, specified by elements of <b><tt>x</tt></b>, and <b><tt>y</tt></b>.</p><p><b>7) <tt>[BiLinearMatrixSearch()]</tt></b> : Function returns a single interpolated value specified by the point (<b><tt>Current_x</tt></b>, <b><tt>Current_y</tt></b>). The function finds the surrounding points needed for the interpolation, rather than having them as an input.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    methods
</pre><pre class="codeinput">    <span class="comment">% Constructor</span>

        <span class="keyword">function</span> obj = bsLinearInterpolation()

        <span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeoutput">
ans = 

  Bootstrap.bsLinearInterpolation with no properties.
  Package: Bootstrap


</pre><h2>Details of methods<a name="9"></a></h2><p><b>1)  <tt>[LinearMatrix()]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns a matrix of interpolated values found using linear interpolation on a raw data matrix. Interpolation is performed on each row of the input data.</p><p><b><i>Inputs</i></b></p><p><b><tt>[x]</tt></b> : <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix specifying the values to be found using linear interpolation.</p><pre>Data type : double array</pre><p><b><tt>[X]</tt></b> : <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix of raw data to be used in the linear interpolation process.</p><pre>Data type : double array</pre><p><b><tt>[Y]</tt></b> : <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix of raw data to be used in the linear interpolation process.</p><pre>Data type : double array</pre><p><b><tt>[Truncate]</tt></b> : Either 'true' or 'false'; specifies whether points outside the range of the raw data input should be truncated to the boundaries of the raw data ('true') or found using extrapolation ('false').</p><pre>Data type : string</pre><p><b><i>Outputs</i></b></p><p><b><tt>[y]</tt></b> : <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix containing interpolated values.</p><pre>Data type : double array</pre><p><b><i>Calculations</i></b></p><p>After checking that <b><tt>Y</tt></b> and <b><tt>X</tt></b> are the same size and allocating space for the output matrix, <b><tt>y</tt></b>, the function, <b><tt>LinearArray()</tt></b>, is called to find the interpolated values specified by elements of <b><tt>x</tt></b> row by row.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Methods and functions</span>

     <span class="keyword">function</span> y = LinearMatrix(obj, x ,  X , Y ,Truncate )

         <span class="comment">% assert( size(x,1) == size(X,1), 'Matrices sizes x &amp; X dont match')</span>
         assert( size(X,1) == size(Y,1), <span class="string">'Matrices sizes X &amp; Y dont match'</span>)
         assert( size(X,2) == size(Y,2), <span class="string">'Matrices sizes X &amp; Y dont match'</span>)

         y = zeros( size(x)); <span class="comment">% Allocate storage space</span>

         <span class="keyword">for</span> i = 1 :  size(X,1)
                 y(i,:) = obj.LinearArray(x(i,1:end), X(i,1:end),<span class="keyword">...</span>
                     Y(i,1:end), Truncate);
         <span class="keyword">end</span>
     <span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1)  <tt>[LinearArray()]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns a row vector of interpolated values found using linear interpolation on a raw data matrix.</p><p><b><i>Inputs</i></b></p><p><b><tt>[x]</tt></b> : Row vector specifying the values to be found through linear interpolation.</p><pre>Data type : double array</pre><p><b><tt>[X]</tt></b> : Row vector of raw data points to be used in the linear interpolation process.</p><pre>Data type : double array</pre><p><b><tt>[Y]</tt></b> : Row vector of raw data points to be used in the linear interpolation process.</p><pre>Data type : double vector</pre><p><b><tt>[Truncate]</tt></b> : Either 'true' or 'false'; specifies whether points outside the range of the raw data should be truncated to the boundaries of the raw data ('true') or found using extrapolation ('false').</p><pre>Data type : string</pre><p><b><i>Outputs</i></b></p><p><b><tt>[y]</tt></b> : Row vector containing linearly interpolated values.</p><pre>Data type : double vector</pre><p><b><i>Calculations</i></b></p><p>First a check that <b><tt>Y</tt></b> and <b><tt>X</tt></b> are both row vectors (and transposing them if they are not) is performed. After creating a matrix <b><tt>y</tt></b> to store results, the function, <b><tt>LinearArraySearch</tt></b>, is called to find interpolated values specified by elements of <b><tt>x</tt></b>.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

    <span class="keyword">function</span> y = LinearArray(obj, x, X, Y,Truncate)

         <span class="keyword">if</span> size(X,2) == 1
            X = X';  <span class="comment">% Algorithm assumes row inputs rather than columns</span>
         <span class="keyword">end</span>

         <span class="keyword">if</span> size(Y,2) == 1
            Y = Y';
         <span class="keyword">end</span>

         y = zeros(1, size(x,2)); <span class="comment">% Allocate storage space</span>

         <span class="keyword">for</span> i = 1 :  size(x,2)
                 y(1,i) = obj.LinearArraySearch(x(1,i), X, Y, Truncate);
         <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1)  <tt>[LinearArraySearch()]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns a single interpolated value. The function finds the raw data points used for the linear interpolation on the raw data array.</p><p><b><i>Inputs</i></b></p><p><b><tt>[Current_x]</tt></b> : Data point specifying the interpolated value to be found.</p><pre>Data type : double</pre><p><b><tt>[X]</tt></b> : Row vector of raw data points to be used in the linear interpolation process.</p><pre>Data type : double vector</pre><p><b><tt>[Y]</tt></b> : Row vector of raw data points to be used in the linear interpolation process.</p><pre>Data type : double vector</pre><p><b><tt>[Truncate]</tt></b> : Either 'true' or 'false'; specifies whether points outside the range of the raw data should be truncated to the boundaries of the raw data ('true') or found using extrapolation ('false').</p><pre>Data type : string</pre><p><b><i>Outputs</i></b></p><p><b><tt>[y]</tt></b> : The interpolated value specified by the input <b><tt>Current_x</tt></b>.</p><pre>Data type : double</pre><p><b><i>Calculations</i></b></p><p>The function finds the two elements of <b><tt>X</tt></b> that most closely surround <b><tt>Current_x</tt></b> and passes them, along with their corresponding elements of <b><tt>Y</tt></b>, to the function, <b><tt>LinearInterpolation()</tt></b>. <b><tt>LinearInterpolation()</tt></b> then returns the value <b><tt>y</tt></b> which is the linearly interpolated value specified by <b><tt>Current_x</tt></b>.</p><p>For values of <b><tt>Current_x</tt></b> that are outside the range of <b><tt>X</tt></b> there are two options. If <b><tt>[Truncate]</tt></b> is 'true' and <b><tt>Current_x</tt></b> is outside the raw data range then the relevant boundary value of raw data is returned for <tt><b>y</b></tt>.</p><p>If <b><tt>Truncate</tt></b> is not 'true' and <b><tt>Current_x</tt></b> is outside the raw data range then the two nearest data points (both on the same side of <b><tt>Current_x</tt></b>) are passed to <b><tt>LinearInterpolation()</tt></b> which uses them to estimate <b><tt>y</tt></b> by linear extrapolation.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeinput">     <span class="keyword">function</span> y = LinearArraySearch(obj, Current_x ,X ,  Y,  Truncate )

        X_Min = X(1, 1);
        X_Max = X(1, end);
        <span class="comment">%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span>
        <span class="comment">%We now need to need the values of X_1,X_2,....., F_21, &amp; F_22 that</span>
        <span class="comment">%straddle the point of interest</span>

        <span class="comment">% Check to see if the point lies outside our grid, set equal to the</span>
        <span class="comment">% equivalent end point</span>

        <span class="keyword">if</span> strcmp(lower(Truncate) , <span class="string">'true'</span>)

            <span class="keyword">if</span> Current_x &lt;= X_Min
                y = Y(1, 1);
                <span class="keyword">return</span>;
            <span class="keyword">elseif</span>  Current_x &gt;= X_Max
                y = Y(1,end);
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
               i = 1 ; <span class="comment">%intialise</span>

                <span class="comment">% The remaining case is to interpolate within the grid</span>

                <span class="keyword">for</span> i = 1 : size(X, 2) - 1 <span class="comment">% The end points have already</span>
                    <span class="comment">% been tested</span>
                    <span class="keyword">if</span> Current_x &gt;= X(1, i ) &amp;&amp; Current_x &lt;= X(1, i+1)
                          <span class="keyword">break</span> <span class="comment">% Exit for loop</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>


        <span class="keyword">else</span>

            <span class="comment">% The following code interpolates within the grid &amp;</span>
            <span class="comment">% extrapolates outwith the grid</span>
            <span class="comment">% Get the X-coordinates</span>

            <span class="keyword">if</span> Current_x &lt;= X_Min
                i = 1;
            <span class="keyword">elseif</span> Current_x &gt;= X_Max
                i = size(X, 2)-1 ;  <span class="comment">% This allows us to use the previous</span>
                                  <span class="comment">% two points to inform us of the gradient</span>
            <span class="keyword">else</span>

                <span class="comment">% First calculate the indices i &amp; j</span>
                <span class="keyword">for</span> i = 1 : size(X, 2) - 1
                    <span class="comment">%The end points have already been tested</span>
                    <span class="keyword">if</span> Current_x &gt;= X(1, i ) &amp;&amp; Current_x &lt;= X(1, i+1)
                        <span class="keyword">break</span> <span class="comment">% Exit for loop</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

            <span class="comment">% Now use interpolation function</span>
            X1 = X(1, i  );
            X2 = X(1, i+1);
            F1 = Y(1, i );
            F2 = Y(1, i+1 );

            y = obj. LinearInterpolation( Current_x , X1 , X2 ,   F1 , F2 );

            <span class="keyword">return</span>;

     <span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1)  <tt>[LinearInterpolation]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns the interpolated value, specified by, <b><tt>x</tt></b>. This is achieved through linear interpolation, using the points (<b><tt>F1</tt></b>, <b><tt>X1</tt></b>) and (<b><tt>F2</tt></b>, <b><tt>X2</tt></b>).</p><p><b><i>Inputs</i></b></p><p><b><tt>[x]</tt></b> : Point specifying the interpolated value to be found.</p><pre>Data type : double</pre><p><b><tt>[X1]</tt></b> : Point specifying the first value used in the linear interpolation calculation.</p><pre>Data type : double</pre><p><b><tt>[X2]</tt></b> : Point specifying the second value used in the linear interpolation calculation.</p><pre>Data type : double</pre><p><b><tt>[F1]</tt></b> : First value used in the linear interpolation calculation.</p><pre>Data type : double</pre><p><b><tt>[F2]</tt></b> : Second value used in the linear interpolation calculation.</p><pre>Data type : double</pre><p><b><i>Outputs</i></b></p><p><b><tt>[y]</tt></b> : Interpolated value specified by, <b><tt>x</tt></b>. This is found by linear interpolation using <b><tt>F1</tt></b>, <b><tt>X1</tt></b>, <b><tt>F2</tt></b> and <b><tt>X2</tt></b>.</p><pre>Data type : double</pre><p><b><i>Calculations</i></b></p><p>Using the expression:</p><p><img src="bsLinearInterpolation_eq00816.png" alt="$$y= F_1+\frac{F_2-F_1}{X_2-X_1}(x-X_1)$$"></p><p>The interpolated value, <img src="bsLinearInterpolation_eq44020.png" alt="$y$">, specified by, <img src="bsLinearInterpolation_eq43551.png" alt="$x$">, is linearly interpolated from the two sets of coordinates <img src="bsLinearInterpolation_eq68680.png" alt="$(F_1,X_1)$"> and <img src="bsLinearInterpolation_eq89737.png" alt="$(F_2,X_2)$">.</p><p>An error is given if, <img src="bsLinearInterpolation_eq48710.png" alt="$X_2-X_1=0$">, as the expression above would not be defined.</p><p><img src="bsLinearInterpolation_eq94566.png" alt="$X_1$"> and <img src="bsLinearInterpolation_eq21514.png" alt="$X_2$">, are expected to be monotonically increasing. So, an error is given if <img src="bsLinearInterpolation_eq55885.png" alt="$X_2<X_1$">.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeinput">    <span class="keyword">function</span> y = LinearInterpolation(obj, x, X1, X2, F1, F2)

        Denominator = (X2 - X1) ;

        <span class="keyword">if</span> Denominator == 0
            error(<span class="string">'Division by Zero'</span>)
        <span class="keyword">end</span>

        <span class="keyword">if</span> (X1 &gt; X2)
             error<span class="keyword">...</span>
             (<span class="string">'Input data must be montonic: Error occurred because X1 &gt; X2'</span>)
        <span class="keyword">end</span>

        y = F1 + ((F2 - F1) / Denominator) * (x- X1) ;

    <span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1)  <tt>[BiLinearInterpolation]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Returns the interpolated value specified by (<b><tt>x</tt></b>, <b><tt>y</tt></b>). Using bilinear interpolation from the coordinates and values of the four input points.</p><p><b><i>Inputs</i></b></p><p><b><tt>[x]</tt></b> : One coordinate used to specify the interpolated value to be output.</p><pre>Date type : double</pre><p><b><tt>[y]</tt></b> : One coordinate used to specify the interpolated value to be output.</p><pre>Date type : double</pre><p><b><tt>[X_1]</tt></b> : The <img src="bsLinearInterpolation_eq43551.png" alt="$x$">-coordinate of two of the points used in the interpolation.</p><pre>Date type : double</pre><p><b><tt>[X_2]</tt></b> : The <img src="bsLinearInterpolation_eq43551.png" alt="$x$">-coordinate of two of the points used in the interpolation.</p><pre>Date type : double</pre><p><b><tt>[Y_1]</tt></b> : The <img src="bsLinearInterpolation_eq44020.png" alt="$y$">-coordinate of two of the points used in the interpolation.</p><pre>Date type : double</pre><p><b><tt>[Y_2]</tt></b> : The <img src="bsLinearInterpolation_eq44020.png" alt="$y$">-coordinate of two of the points used in the interpolation.</p><pre>Date type : double</pre><p><b><tt>[F_11]</tt></b> : The value of the point, specified by <b><tt>X_1</tt></b> and <b><tt>Y_1</tt></b>, used in the bilinear interpolation calculation.</p><pre>Date type : double</pre><p><b><tt>[F_12]</tt></b> : The value of the point, specified by <b><tt>X_1</tt></b> and <b><tt>Y_2</tt></b>, used in the bilinear interpolation calculation.</p><pre>Date type : double</pre><p><b><tt>[F_21]</tt></b> : The value of the point, specified by <b><tt>X_2</tt></b> and <b><tt>Y_1</tt></b>, used in the bilinear interpolation calculation.</p><pre>Date type : double</pre><p><b><tt>[F_22]</tt></b> : The value of the point, specified by <b><tt>X_2</tt></b> and <b><tt>Y_2</tt></b>, used in the bilinear interpolation calculation.</p><pre>Date type : double</pre><p><b><i>Outputs</i></b></p><p>The interpolated value specified by the point (<b><tt>x</tt></b>, <b><tt>y</tt></b>).</p><pre>Data type : double</pre><p><b><i>Calculations</i></b></p><p>The interpolated value, <img src="bsLinearInterpolation_eq85998.png" alt="$f$">, specified by <img src="bsLinearInterpolation_eq00101.png" alt="$(x, y)$">, is calculated using the expression below. The point <img src="bsLinearInterpolation_eq57428.png" alt="$(x,y)$"> is surrounded by a rectangle with vertices; <img src="bsLinearInterpolation_eq05922.png" alt="$(X_1, Y_1)$">, <img src="bsLinearInterpolation_eq61244.png" alt="$(X_1, Y_2)$">, <img src="bsLinearInterpolation_eq87383.png" alt="$(X_2, Y_1)$"> and <img src="bsLinearInterpolation_eq90788.png" alt="$(X_2, Y_2)$">.</p><p><img src="bsLinearInterpolation_eq90365.png" alt="$f=$"></p><p><img src="bsLinearInterpolation_eq58398.png" alt="$$\frac{(X_2-x)(Y_2-y)F_{11}+(x-X_1)(Y_2-y)F_{21}+(X_2-x)(y-Y_1)F_{12}+&#xA;(x-X_1)(y-Y_2)F_{22}}{\left(X_2-X_1\right)\left(Y_2-Y_1\right)}$$"></p><p>The indices on each, <img src="bsLinearInterpolation_eq18529.png" alt="$F_{ij}$">, correlate to their <img src="bsLinearInterpolation_eq03598.png" alt="$X$"> and <img src="bsLinearInterpolation_eq17977.png" alt="$Y$"> coordinates e.g. <img src="bsLinearInterpolation_eq07432.png" alt="$F_{21}$"> is specified by <img src="bsLinearInterpolation_eq24187.png" alt="$(X_2,Y_1)$"> and so on.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeinput">    <span class="keyword">function</span> f = BiLinearInterpolation(obj, x, y, X_1, X_2, Y_1, Y_2, <span class="keyword">...</span>
                                                   F_11, F_12, F_21, F_22)

        Denominator = (X_2 - X_1) * (Y_2 - Y_1);

        <span class="keyword">if</span> Denominator == 0
            error(<span class="string">'Division by Zero'</span>)
        <span class="keyword">end</span>

        <span class="keyword">if</span> (X_1 &gt; X_2)   ||  (Y_1 &gt; Y_2)
            error(<span class="keyword">...</span>
<span class="string">'Input data must be montonic: Error occurred because either X_1 &gt; X_2 OR Y_1 &gt; Y_2'</span>)
        <span class="keyword">end</span>

        f = (1 / Denominator) * ((X_2 - x) * (Y_2 - y) * F_11 +<span class="keyword">...</span>
            (x - X_1) * (Y_2 - y) * F_21 + (X_2 - x) * (y - Y_1) * F_12 +<span class="keyword">...</span>
            (x - X_1) * (y - Y_1) * F_22);

    <span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1)  <tt>[BiLinearMatrix]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns a matrix of bilinearly interpolated values, specified by the vectors, <b><tt>x</tt></b> and <b><tt>y</tt></b>.</p><p><b><i>Inputs</i></b></p><p><b><tt>[x]</tt></b> : Row vector specifying the values to be found through bilinear interpolation.</p><pre>Data type : double vector</pre><p><b><tt>[X]</tt></b> : Row vector of raw data to be used in the bilinear interpolation process.</p><pre>Data type : double vector</pre><p><b><tt>[y]</tt></b> : Row vector specifying the values to be found through bilinear interpolation.</p><pre>Data type : double vector</pre><p><b><tt>[Y]</tt></b> : Row vector of raw data to be used in the bilinear interpolation process.</p><pre>Data type : double vector</pre><p><b><tt>[Grid]</tt></b> : A matrix of raw data values, each corresponding to a pair of <b><tt>X</tt></b> and <b><tt>Y</tt></b> elements.</p><pre>Data type : double array</pre><p><b><tt>[Truncate]</tt></b> : Either 'true' or 'false'; specifies whether points outside the range of the raw data grid should be truncated to the boundaries of the raw data ('true') or found using extrapolation ('false').</p><pre>Data type : string</pre><p><b><i>Outputs</i></b></p><p>An <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix of interpolated values corresponding to pairs of <b><tt>x</tt></b> and <b><tt>y</tt></b> elements.</p><pre>Data type : double array</pre><p><b><i>Calculations</i></b></p><p>A matrix, <b><tt>z</tt></b>, is created to store results. Then, elements of <b><tt>x</tt></b> and <b><tt>y</tt></b> are passed to <b><tt>BiLinearSearch()</tt></b>, one pair at a time.</p><p><tt><b>BilinearSearch()</b></tt> then returns the bilinearly interpolated results, which populate the matrix, <b><tt>z</tt></b>, point by point.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeinput">    <span class="keyword">function</span> z = BiLinearMatrix(obj, x , y , X ,  Y , Grid, Truncate )

         z = zeros(  size(x,2),size(y,2) ); <span class="comment">% Allocate storage space</span>

         <span class="keyword">for</span> i = 1 :  size(x,2)
             <span class="keyword">for</span> j = 1 :  size(y,2)
                 z(i,j) = obj.BiLinearMatrixSearch(x(1,i), y(1,j), X,  Y,<span class="keyword">...</span>
                     Grid, Truncate);
             <span class="keyword">end</span>
         <span class="keyword">end</span>
    <span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1)  <tt>[BiLinearMatrixSearch]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns a single interpolated value, specified by the single point (<b><tt>Current_x</tt></b>, <b><tt>Current_y</tt></b>). The function locates the surrounding points, needed for the bilinear interpolation, from the raw data inputs.</p><p><b><i>Inputs</i></b></p><p><b><tt>[Current_x]</tt></b> : <img src="bsLinearInterpolation_eq43551.png" alt="$x$">-coordinate of the point specifying the value to be found through bilinear interpolation.</p><pre>Data type : double</pre><p><b><tt>[Current_y]</tt></b> : <img src="bsLinearInterpolation_eq44020.png" alt="$y$">-coordinate of the point specifying the value to be found through bilinear interpolation.</p><pre>Data type : double</pre><p><b><tt>[X]</tt></b> : Row vector of raw data to be used in the bilinear interpolation process.</p><pre>Data type : double</pre><p><b><tt>[Y]</tt></b> : Row vector of raw data to be used in the bilinear interpolation process.</p><pre>Data type : double</pre><p><b><tt>[Grid]</tt></b> : <img src="bsLinearInterpolation_eq68137.png" alt="$n\times n$"> matrix of raw data corresponding to elements of <b><tt>X</tt></b> and <b><tt>Y</tt></b>.</p><pre>Data type : double array</pre><p><b><tt>[Truncate]</tt></b> : Either 'true' or 'false'; specifies whether points outside the range of the raw data should be truncated to the boundaries of the raw data ('true') or found using extrapolation ('false').</p><pre>Data type : string</pre><p><b><i>Outputs</i></b></p><p>Interpolated value, specified by  the point (<b><tt>Current_x</tt></b>, <b><tt>Current_y</tt></b>).</p><pre>Date type : double</pre><p><b><i>Calculations</i></b></p><p>The function finds the four points with coordinates from elements of <b><tt>X</tt></b> and <b><tt>Y</tt></b> that most closely surround the point (<b><tt>Current_x</tt></b>, <b><tt>Current_y</tt></b>) and passes them (along with the corresponding elements of <b><tt>Grid</tt></b>) to the function, <b><tt>BiLinearInterpolation()</tt></b>.</p><p><b><tt>BiLinearInterpolation()</tt></b> then returns the bilinearly interpolated value, specified by (<b><tt>Current_x</tt></b>, <b><tt>Current_y</tt></b>).</p><p>For values of <b><tt>Current_x</tt></b> or <b><tt>Current_y</tt></b> that are outside the range of <b><tt>X</tt></b> there are two options, which are controlled with the property <b><tt>Truncate</tt></b>.</p><p>If <b><tt>Truncate</tt></b> is 'true' and both, <b><tt>Current_x</tt></b> and <b><tt>Current_y</tt></b> are outside the raw data range then the relevant boundary value of raw data is returned for <tt><b>z</b></tt>.</p><p>If <b><tt>Truncate</tt></b> is 'true' and only one of <b><tt>Current_x</tt></b> and <b><tt>Current_y</tt></b> are outside of the range of the raw data, the boundary value of the <b><tt>Grid</tt></b> is used in the direction that extends past the raw data. In the direction that is covered by the raw data bilinear interpolate is conducted here instead of calling <b><tt>BiLinearInterpolation()</tt></b>.</p><p>If <b><tt>Truncate</tt></b> is not 'true' and <b><tt>Current_x</tt></b> or <b><tt>Current_y</tt></b> are outside the raw data range then the two nearest data points (both on the same side of <b><tt>Current_x</tt></b> or <b><tt>Current_y</tt></b>) are passed to <b><tt>LinearInterpolation()</tt></b> which uses them to estimate <b><tt>z</tt></b> by extrapolation.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeinput">    <span class="keyword">function</span> y = BiLinearMatrixSearch(obj, Current_x, Current_y, X, Y,<span class="keyword">...</span>
            Grid, Truncate)

        Y_Min = Y(1, 1);
        Y_Max = Y(1, end);
        X_Min = X(1, 1);
        X_Max = X(1, end);
        <span class="comment">%We now need to need the values of X_1,X_2,....., F_21, &amp; F_22 that</span>
        <span class="comment">% straddle the point of interest</span>

        <span class="comment">% Check to see if the point lies outside our grid, set equal to the</span>
        <span class="comment">% equivalent end point</span>

        <span class="keyword">if</span> strcmp(lower(Truncate) , <span class="string">'true'</span>)

            <span class="keyword">if</span> Current_y &lt;= Y_Min &amp;&amp; Current_x &lt;= X_Min
                y = Grid(1, 1);
                <span class="keyword">return</span>;
            <span class="keyword">elseif</span> Current_y &lt;= Y_Min &amp;&amp; Current_x &gt;= X_Max
                y = Grid(end, 1);
                <span class="keyword">return</span>;
            <span class="keyword">elseif</span> Current_y &gt;= Y_Max &amp;&amp; Current_x &lt;= X_Min
                y = Grid(1, end);
                <span class="keyword">return</span>;
            <span class="keyword">elseif</span> Current_y &gt;= Y_Max &amp;&amp; Current_x &gt;= X_Max
                y = Grid(end, end);
                <span class="keyword">return</span>;
            <span class="keyword">end</span>

            <span class="comment">% Check to see if the point lies on the either of the time</span>
            <span class="comment">% boundaries</span>

            i = 1 ; <span class="comment">%intialise</span>
            j = 1 ; <span class="comment">%intialise</span>
            <span class="comment">% k = 0 ; %intialise</span>

            <span class="keyword">if</span> Current_y &lt;= Y_Min
                <span class="keyword">for</span> i = 1 : size(X, 2)-1 <span class="comment">%End points have already been tested</span>
                    <span class="keyword">if</span> Current_x &gt;= X(1, i ) &amp;&amp; Current_x &lt;= X(1,i+1)
                        <span class="comment">% Reduces to linear interpolation</span>
                        y = (Current_x - X(1, i )) / (X(1,i+1) - X(1,i )) <span class="keyword">...</span>
                            * Grid(i+1, 1) + Grid(i , 1) * <span class="keyword">...</span>
                            (1 - (Current_x - X(1,i )) <span class="keyword">...</span>
                            / (X(1, i+1) - X(1, i )));
                       <span class="keyword">return</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

            <span class="keyword">elseif</span> Current_y &gt;= Y_Max
                <span class="keyword">for</span> i = 1 : size(X, 2) - 1 <span class="comment">%End points have already been tested</span>
                    <span class="keyword">if</span> Current_x &gt;= X(1,i ) &amp;&amp; Current_x &lt;= X(1, i+1)

                        y = (Current_x - X(1, i )) / (X(1, i+1) - X(1,i )) <span class="keyword">...</span>
                            * Grid(i+1, size(Y, 2)) + Grid(i , size(Y, 2)) * <span class="keyword">...</span>
                            (1 - (Current_x - X(1, i )) <span class="keyword">...</span>
                            / (X(1,i+1) - X(1,i )));
                       <span class="keyword">return</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>


            <span class="keyword">if</span> Current_x &lt;= X_Min
                <span class="keyword">for</span> i = 1 : size(Y, 2) - 1 <span class="comment">%End points have already been tested</span>
                    <span class="keyword">if</span> Current_y &gt;= Y(1, i ) &amp;&amp; Current_y &lt;= Y(1, i+1)

                        y = (Current_y - Y(1, i )) / (Y(1, i+1) - Y(1, i )) <span class="keyword">...</span>
                            * Grid(1, i+1) + Grid(1, i ) * <span class="keyword">...</span>
                            (1 - (Current_y - Y(1, i ))<span class="keyword">...</span>
                            / (Y(1, i+1) - Y(1, i )));

                        <span class="keyword">return</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">elseif</span> Current_x &gt;= X_Max
                <span class="keyword">for</span> i = 1 : size(Y, 2) - 1 <span class="comment">%End points have already been tested</span>
                    <span class="keyword">if</span> Current_y &gt;= Y(1, i ) &amp;&amp; Current_y &lt;= Y(1, i+1)

                        y = (Current_y - Y(1, i )) / (Y(1, i+1) - Y(1, i ))<span class="keyword">...</span>
                            * Grid(size(X, 2), i+1) + Grid(size(X, 2), i ) * <span class="keyword">...</span>
                            (1 - (Current_y - Y(1, i ))<span class="keyword">...</span>
                            / (Y(1, i+1) - Y(1, i )));
                        <span class="keyword">return</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">end</span>


                <span class="comment">%The remaining case is to interpolate within the grid</span>

                <span class="comment">%First calculate the indices i &amp; j</span>
                <span class="keyword">for</span> i = 1 : size(X, 2) - 1 <span class="comment">%End points have already been tested</span>
                    <span class="keyword">if</span> Current_x &gt;= X(1, i ) &amp;&amp; Current_x &lt;= X(1, i+1)
                          <span class="keyword">break</span> <span class="comment">% Exit for loop</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="keyword">for</span> j = 1 : size(Y, 2) - 1 <span class="comment">%End points have already been tested</span>
                    <span class="keyword">if</span> Current_y &gt;= Y(1, j ) &amp;&amp; Current_y &lt;= Y(1, j+1)
                          <span class="keyword">break</span> <span class="comment">% Exit for loop</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>


        <span class="keyword">else</span>

            <span class="comment">% The following code interpolates within the grid &amp;</span>
            <span class="comment">% extrapolates outside the grid</span>

            <span class="comment">% Get the X-coordinates</span>

            <span class="keyword">if</span> Current_x &lt;= X_Min
                i = 1;
            <span class="keyword">elseif</span> Current_x &gt;= X_Max
                i = size(X, 2)-1 ;  <span class="comment">% This allows us to use the previous</span>
                                <span class="comment">% two points to inform us of the gradient</span>
            <span class="keyword">else</span>

                <span class="comment">% First calculate the indices i &amp; j</span>
                <span class="keyword">for</span> i = 1 : size(X, 2) - 1
                    <span class="keyword">if</span> Current_x &gt;= X(1, i ) &amp;&amp; Current_x &lt;= X(1, i+1)
                         <span class="keyword">break</span> <span class="comment">% Exit for loop</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

            <span class="keyword">end</span>


            <span class="comment">% Get the Y-coordinates</span>

            <span class="keyword">if</span> Current_y &lt;= Y_Min
                j = 1;
            <span class="keyword">elseif</span> Current_y &gt;= Y_Max
                j = size(Y, 2) -1 ;  <span class="comment">% This allows us to use the previous</span>
                                <span class="comment">% two points to inform us of the gradient</span>
            <span class="keyword">else</span>

                <span class="keyword">for</span> j = 1 : size(Y, 2) - 1
                    <span class="keyword">if</span> Current_y &gt;= Y(1, j ) &amp;&amp; Current_y &lt;= Y(1, j+1)
                        <span class="keyword">break</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

            <span class="keyword">end</span>


        <span class="keyword">end</span>

            <span class="comment">% Now use interpolation function</span>

            X_1 = X(1, i  );
            X_2 = X(1, i+1);
            Y_1 = Y(1, j );
            Y_2 = Y(1, j+1);

            F_11 = Grid(i , j );
            F_12 = Grid(i , j+1);
            F_21 = Grid(i+1, j );
            F_22 = Grid(i+1, j+1);

            y = obj.BiLinearInterpolation(Current_x, Current_y, X_1, X_2, <span class="keyword">...</span>
                Y_1, Y_2, F_11, F_12, F_21, F_22);

            <span class="keyword">return</span>;



    <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.11.1<br></p></div><!--
##### SOURCE BEGIN #####
%% Linear Interpolation (functions)
% *The class contains a number of linear interpolation functions which are 
% intended, specifically, to give the user more functionality
% concerning extrapolation than is provided by the standard MatLab library.*
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef bsLinearInterpolation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% How to use the class
% There are two ways to use the class:
%
% # To produce an array (whether it be an $n\times n$ matrix, a vector or 
% just a single value) of points interpolated from a raw data object, using
% linear interpolation in rows. 
% # To produce an array (whether it be an $n\times n$ matrix, a vector or 
% just a single value) of points interpolated from a two dimensional raw
% data object, using bilinear interpolation.
%
%
%% Properties
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    properties
    end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% List of methods
% The class introduces seven new methods:
%
% *1) |[LinearMatrix()]|* : Function returns a matrix of interpolated values
% found using linear interpolation on a raw data set.
%
% *2) |[LinearArray()]|* : Function returns a row vector of interpolated 
% values found using linear interpolation on a raw data set.
%
% *3) |[LinearArraySearch()]|* : Function returns a single interpolated 
% value found using linear interpolation on a raw data set. The function
% finds the raw data points used for the interpolation from the raw data#
% set.
%
% *4) |[LinearInterpolation()]|* : Function returns a single interpolated 
% value. This is calculated through linear interpolation, using the points
% (*|F1|*, *|X1|*) and (*|F2|*, *|X2|*), which are inputs of the function.
%
% *5) |[BiLinearInterpolation()]|* : Function returns a single interpolated 
% value, specified by the point (*|x|*, *|y|*), using bilinear interpolation
% from the four input points.
%
% *6) |[BiLinearMatrix()]|* : Function returns a matrix of bilinearly 
% interpolated values, specified by elements of *|x|*, and *|y|*. 
%
% *7) |[BiLinearMatrixSearch()]|* : Function returns a single interpolated
% value specified by the point (*|Current_x|*, *|Current_y|*). The function
% finds the surrounding points needed for the interpolation, rather than 
% having them as an input.
%
%%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    methods
    % Constructor    
    
        function obj = bsLinearInterpolation()

        end
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Details of methods 
%
% *1)  |[LinearMatrix()]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns a matrix of interpolated values found using linear 
% interpolation on a raw data matrix. Interpolation is performed on each
% row of the input data.
%
% *_Inputs_*
%
% *|[x]|* : $n\times n$ matrix specifying the values to be found using 
% linear interpolation.
%
%  Data type : double array
%
% *|[X]|* : $n\times n$ matrix of raw data to be used in the linear 
% interpolation process.
%
%  Data type : double array
%
% *|[Y]|* : $n\times n$ matrix of raw data to be used in the linear 
% interpolation process.
%
%  Data type : double array
%
% *|[Truncate]|* : Either 'true' or 'false'; specifies whether points
% outside the range of the raw data input should be truncated to the
% boundaries of the raw data ('true') or found using extrapolation 
% ('false').
%
%  Data type : string
%
% *_Outputs_*
%
% *|[y]|* : $n\times n$ matrix containing interpolated values.
%
%  Data type : double array
%
% *_Calculations_*
%
% After checking that *|Y|* and *|X|* are the same size and allocating space
% for the output matrix, *|y|*, the function, *|LinearArray()|*, is called to
% find the interpolated values specified by elements of *|x|* row by row. 
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Methods and functions    
     
     function y = LinearMatrix(obj, x ,  X , Y ,Truncate )
        
         % assert( size(x,1) == size(X,1), 'Matrices sizes x & X dont match')
         assert( size(X,1) == size(Y,1), 'Matrices sizes X & Y dont match')
         assert( size(X,2) == size(Y,2), 'Matrices sizes X & Y dont match')
                  
         y = zeros( size(x)); % Allocate storage space
        
         for i = 1 :  size(X,1)            
                 y(i,:) = obj.LinearArray(x(i,1:end), X(i,1:end),...
                     Y(i,1:end), Truncate);
         end
     end  
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
% *1)  |[LinearArray()]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns a row vector of interpolated values found using linear
% interpolation on a raw data matrix.
%
% *_Inputs_*
%
% *|[x]|* : Row vector specifying the values to be found through linear 
% interpolation.
%
%  Data type : double array
%
% *|[X]|* : Row vector of raw data points to be used in the linear
% interpolation process.
%
%  Data type : double array
%
% *|[Y]|* : Row vector of raw data points to be used in the linear
% interpolation process.
%
%  Data type : double vector
%
% *|[Truncate]|* : Either 'true' or 'false'; specifies whether points
% outside the range of the raw data should be truncated to the boundaries
% of the raw data ('true') or found using extrapolation ('false').
%
%  Data type : string
%
% *_Outputs_*
%
% *|[y]|* : Row vector containing linearly interpolated values.
%
%  Data type : double vector
%
% *_Calculations_*
%
% First a check that *|Y|* and *|X|* are both row vectors (and transposing 
% them if they are not) is performed. After creating a matrix *|y|* to 
% store results, the function, *|LinearArraySearch|*, is 
% called to find interpolated values specified by elements of *|x|*. 
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
    
    function y = LinearArray(obj, x, X, Y,Truncate)
        
         if size(X,2) == 1
            X = X';  % Algorithm assumes row inputs rather than columns
         end
         
         if size(Y,2) == 1
            Y = Y'; 
         end
                  
         y = zeros(1, size(x,2)); % Allocate storage space
        
         for i = 1 :  size(x,2)            
                 y(1,i) = obj.LinearArraySearch(x(1,i), X, Y, Truncate);
         end
    end  
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
% *1)  |[LinearArraySearch()]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns a single interpolated value. The function finds the raw 
% data points used for the linear interpolation on the raw data array.
%
% *_Inputs_*
%
% *|[Current_x]|* : Data point specifying the interpolated value to be 
% found.
%
%  Data type : double
%
% *|[X]|* : Row vector of raw data points to be used in the linear 
% interpolation process.
%
%  Data type : double vector
%
% *|[Y]|* : Row vector of raw data points to be used in the linear 
% interpolation process.
%
%  Data type : double vector
%
% *|[Truncate]|* : Either 'true' or 'false'; specifies whether points
% outside the range of the raw data should be truncated to the boundaries
% of the raw data ('true') or found using extrapolation ('false').
%
%  Data type : string
%
% *_Outputs_*
%
% *|[y]|* : The interpolated value specified by the input *|Current_x|*.
%
%  Data type : double
%
% *_Calculations_*
%
% The function finds the two elements of *|X|* that most closely surround 
% *|Current_x|* and passes them, along with their corresponding elements of
% *|Y|*, to the function, *|LinearInterpolation()|*.
% *|LinearInterpolation()|* then returns the value *|y|* which is the 
% linearly interpolated value specified by *|Current_x|*.
% 
% For values of *|Current_x|* that are outside the range of *|X|* there are 
% two options. If *|[Truncate]|* is 'true' and *|Current_x|* is outside the
% raw data range then the relevant boundary value of raw data is returned
% for |*y*|.
%
% If *|Truncate|* is not 'true' and *|Current_x|* is outside the
% raw data range then the two nearest data points (both on the same side
% of *|Current_x|*) are passed to *|LinearInterpolation()|* which uses 
% them to estimate *|y|* by linear extrapolation.
%
%
%
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    %%
    
     function y = LinearArraySearch(obj, Current_x ,X ,  Y,  Truncate )
                 
        X_Min = X(1, 1);
        X_Max = X(1, end);
        %'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        %We now need to need the values of X_1,X_2,....., F_21, & F_22 that
        %straddle the point of interest
        
        % Check to see if the point lies outside our grid, set equal to the
        % equivalent end point
        
        if strcmp(lower(Truncate) , 'true')
            
            if Current_x <= X_Min
                y = Y(1, 1);
                return;
            elseif  Current_x >= X_Max
                y = Y(1,end);
                return;
            end
               i = 1 ; %intialise
            
                % The remaining case is to interpolate within the grid
                               
                for i = 1 : size(X, 2) - 1 % The end points have already 
                    % been tested
                    if Current_x >= X(1, i ) && Current_x <= X(1, i+1)
                          break % Exit for loop
                    end
                end
                
                
        else
            
            % The following code interpolates within the grid & 
            % extrapolates outwith the grid
            % Get the X-coordinates   
            
            if Current_x <= X_Min
                i = 1;
            elseif Current_x >= X_Max
                i = size(X, 2)-1 ;  % This allows us to use the previous 
                                  % two points to inform us of the gradient
            else
                
                % First calculate the indices i & j
                for i = 1 : size(X, 2) - 1 
                    %The end points have already been tested
                    if Current_x >= X(1, i ) && Current_x <= X(1, i+1)
                        break % Exit for loop
                    end
                end
            end
                
        end
                       
            % Now use interpolation function            
            X1 = X(1, i  );
            X2 = X(1, i+1);
            F1 = Y(1, i );            
            F2 = Y(1, i+1 );   
            
            y = obj. LinearInterpolation( Current_x , X1 , X2 ,   F1 , F2 );            
            
            return;
            
     end
    
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
% *1)  |[LinearInterpolation]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns the interpolated value, specified by, *|x|*. This is 
% achieved through linear interpolation, using the points (*|F1|*, *|X1|*)
% and (*|F2|*, *|X2|*).
%
% *_Inputs_*
%
% *|[x]|* : Point specifying the interpolated value to be
% found.
%
%  Data type : double
%
% *|[X1]|* : Point specifying the first value used in the linear
% interpolation calculation.
%
%  Data type : double
%
% *|[X2]|* : Point specifying the second value used in the linear
% interpolation calculation.
%
%  Data type : double
%
% *|[F1]|* : First value used in the linear interpolation calculation.
%
%  Data type : double
%
% *|[F2]|* : Second value used in the linear interpolation calculation.
%
%  Data type : double
% 
% *_Outputs_*
%
% *|[y]|* : Interpolated value specified by, *|x|*. This is
% found by linear interpolation using *|F1|*, *|X1|*, *|F2|* and *|X2|*.
%
%  Data type : double
%
% *_Calculations_*
%
% Using the expression:
%
% $$y= F_1+\frac{F_2-F_1}{X_2-X_1}(x-X_1)$$
%
% The interpolated value, $y$, specified by, $x$, is linearly
% interpolated from the two sets of coordinates $(F_1,X_1)$ and 
% $(F_2,X_2)$. 
%
% An error is given if, $X_2-X_1=0$, as the expression above would not be
% defined.
% 
% $X_1$ and $X_2$, are expected to be monotonically increasing.
% So, an error is given if $X_2<X_1$.
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
    %%
    function y = LinearInterpolation(obj, x, X1, X2, F1, F2)
   
        Denominator = (X2 - X1) ;
        
        if Denominator == 0            
            error('Division by Zero')            
        end
        
        if (X1 > X2) 
             error...
             ('Input data must be montonic: Error occurred because X1 > X2')            
        end
        
        y = F1 + ((F2 - F1) / Denominator) * (x- X1) ;
                
    end
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
% *1)  |[BiLinearInterpolation]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Returns the interpolated value specified by (*|x|*, *|y|*). Using 
% bilinear interpolation from the coordinates and values of the four input
% points.
%
% *_Inputs_*
%
% *|[x]|* : One coordinate used to specify the interpolated value to be
% output.
%
%  Date type : double
%
% *|[y]|* : One coordinate used to specify the interpolated value to be
% output.
%
%  Date type : double
%
% *|[X_1]|* : The $x$-coordinate of two of the points used in the 
% interpolation.
%
%  Date type : double
%
% *|[X_2]|* : The $x$-coordinate of two of the points used in the 
% interpolation.
%
%  Date type : double
%
% *|[Y_1]|* : The $y$-coordinate of two of the points used in the 
% interpolation.
%
%  Date type : double
%
% *|[Y_2]|* : The $y$-coordinate of two of the points used in the 
% interpolation.
%
%  Date type : double
%
% *|[F_11]|* : The value of the point, specified by *|X_1|* and
% *|Y_1|*, used in the bilinear interpolation calculation.
%
%  Date type : double
%
% *|[F_12]|* : The value of the point, specified by *|X_1|* and
% *|Y_2|*, used in the bilinear interpolation calculation.
%
%  Date type : double
%
% *|[F_21]|* : The value of the point, specified by *|X_2|* and
% *|Y_1|*, used in the bilinear interpolation calculation.
%
%  Date type : double
%
% *|[F_22]|* : The value of the point, specified by *|X_2|* and
% *|Y_2|*, used in the bilinear interpolation calculation.
%
%  Date type : double
%
% *_Outputs_*
%
% The interpolated value specified by the point (*|x|*, *|y|*). 
%
%  Data type : double
%
% *_Calculations_*
%
% The interpolated value, $f$, specified by $(x, y)$, is 
% calculated using the expression below. The point $(x,y)$ is surrounded by 
% a rectangle with vertices; $(X_1, Y_1)$, $(X_1, Y_2)$, $(X_2, Y_1)$ and
% $(X_2, Y_2)$.
%%
%
% $f=$
%
% $$\frac{(X_2-x)(Y_2-y)F_{11}+(x-X_1)(Y_2-y)F_{21}+(X_2-x)(y-Y_1)F_{12}+
% (x-X_1)(y-Y_2)F_{22}}{\left(X_2-X_1\right)\left(Y_2-Y_1\right)}$$
%
% The indices on each, $F_{ij}$, correlate to their $X$ and $Y$ 
% coordinates e.g. $F_{21}$ is specified by $(X_2,Y_1)$ and so on.
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
      %%  
    function f = BiLinearInterpolation(obj, x, y, X_1, X_2, Y_1, Y_2, ...
                                                   F_11, F_12, F_21, F_22)
        
        Denominator = (X_2 - X_1) * (Y_2 - Y_1);
        
        if Denominator == 0
            error('Division by Zero')
        end
    
        if (X_1 > X_2)   ||  (Y_1 > Y_2)
            error(...
'Input data must be montonic: Error occurred because either X_1 > X_2 OR Y_1 > Y_2')
        end
        
        f = (1 / Denominator) * ((X_2 - x) * (Y_2 - y) * F_11 +...
            (x - X_1) * (Y_2 - y) * F_21 + (X_2 - x) * (y - Y_1) * F_12 +...
            (x - X_1) * (y - Y_1) * F_22);
        
    end
      
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
% *1)  |[BiLinearMatrix]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns a matrix of bilinearly interpolated values, specified
% by the vectors, *|x|* and *|y|*.
%
% *_Inputs_*
%
% *|[x]|* : Row vector specifying the values to be found through bilinear 
% interpolation.
%
%  Data type : double vector
%
% *|[X]|* : Row vector of raw data to be used in the bilinear interpolation
% process.
%
%  Data type : double vector
%
% *|[y]|* : Row vector specifying the values to be found through bilinear 
% interpolation.
%
%  Data type : double vector
%
% *|[Y]|* : Row vector of raw data to be used in the bilinear interpolation
% process.
%
%  Data type : double vector
%
% *|[Grid]|* : A matrix of raw data values, each corresponding to a pair of
% *|X|* and *|Y|* elements.
%
%  Data type : double array
%
% *|[Truncate]|* : Either 'true' or 'false'; specifies whether points
% outside the range of the raw data grid should be truncated to the 
% boundaries of the raw data ('true') or found using extrapolation 
% ('false').
%
%  Data type : string
%
% *_Outputs_*
%
% An $n\times n$ matrix of interpolated values corresponding to pairs of
% *|x|* and *|y|* elements.
%
%  Data type : double array
%
% *_Calculations_*
%
% A matrix, *|z|*, is created to store results. Then, elements of *|x|* and
% *|y|* are passed to *|BiLinearSearch()|*, one pair at a time. 
% 
% |*BilinearSearch()*| then returns the bilinearly interpolated results, 
% which populate the matrix, *|z|*, point by point.
%
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    %%   
    function z = BiLinearMatrix(obj, x , y , X ,  Y , Grid, Truncate )
        
         z = zeros(  size(x,2),size(y,2) ); % Allocate storage space
        
         for i = 1 :  size(x,2)
             for j = 1 :  size(y,2)
                 z(i,j) = obj.BiLinearMatrixSearch(x(1,i), y(1,j), X,  Y,...
                     Grid, Truncate);
             end
         end
    end   
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
% *1)  |[BiLinearMatrixSearch]|* 
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns a single interpolated value, specified by the single 
% point (*|Current_x|*, *|Current_y|*). The function locates the 
% surrounding points, needed for the bilinear interpolation, from the raw
% data inputs.
%
% *_Inputs_*
%
% *|[Current_x]|* : $x$-coordinate of the point specifying the value to be 
% found through bilinear interpolation.
%
%  Data type : double
%
% *|[Current_y]|* : $y$-coordinate of the point specifying the value to be 
% found through bilinear interpolation.
%
%  Data type : double
%
% *|[X]|* : Row vector of raw data to be used in the bilinear interpolation
% process.
%
%  Data type : double
%
% *|[Y]|* : Row vector of raw data to be used in the bilinear interpolation
% process.
%
%  Data type : double
%
% *|[Grid]|* : $n\times n$ matrix of raw data corresponding to elements of 
% *|X|* and *|Y|*.
%
%  Data type : double array
%
% *|[Truncate]|* : Either 'true' or 'false'; specifies whether points
% outside the range of the raw data should be truncated to the boundaries
% of the raw data ('true') or found using extrapolation ('false').
%
%  Data type : string
%
% *_Outputs_*
%
% Interpolated value, specified by  the point (*|Current_x|*,
% *|Current_y|*).
%
%  Date type : double
% 
% *_Calculations_*
%
% The function finds the four points with coordinates from elements of
% *|X|* and *|Y|* that most closely surround the point 
% (*|Current_x|*, *|Current_y|*) and passes them (along with the 
% corresponding elements of *|Grid|*) to the function, 
% *|BiLinearInterpolation()|*. 
% 
% *|BiLinearInterpolation()|* then returns the bilinearly interpolated 
% value, specified by (*|Current_x|*, *|Current_y|*).
% 
% For values of *|Current_x|* or *|Current_y|* that are outside the range 
% of *|X|* there are two options, which are controlled with the property
% *|Truncate|*.
%
% If *|Truncate|* is 'true' and both, *|Current_x|* and *|Current_y|* are
% outside the raw data range then the relevant boundary value of raw data 
% is returned for |*z*|.
% 
% If *|Truncate|* is 'true' and only one of *|Current_x|* and 
% *|Current_y|* are outside of the range of the raw data, the boundary
% value of the *|Grid|* is used in the direction that extends past the raw
% data. In the direction that is covered by the raw data bilinear
% interpolate is conducted here instead of calling
% *|BiLinearInterpolation()|*.
%
% If *|Truncate|* is not 'true' and *|Current_x|* or *|Current_y|* are
% outside the raw data range then the two nearest data points (both on the
% same side of *|Current_x|* or *|Current_y|*) are passed to 
% *|LinearInterpolation()|* which uses them to estimate *|z|* by 
% extrapolation.
%
%
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    
    %%
    function y = BiLinearMatrixSearch(obj, Current_x, Current_y, X, Y,...
            Grid, Truncate)
              
        Y_Min = Y(1, 1);
        Y_Max = Y(1, end);
        X_Min = X(1, 1);
        X_Max = X(1, end);
        %We now need to need the values of X_1,X_2,....., F_21, & F_22 that
        % straddle the point of interest
        
        % Check to see if the point lies outside our grid, set equal to the
        % equivalent end point
        
        if strcmp(lower(Truncate) , 'true')
            
            if Current_y <= Y_Min && Current_x <= X_Min
                y = Grid(1, 1);
                return;
            elseif Current_y <= Y_Min && Current_x >= X_Max
                y = Grid(end, 1);
                return;
            elseif Current_y >= Y_Max && Current_x <= X_Min
                y = Grid(1, end);
                return;
            elseif Current_y >= Y_Max && Current_x >= X_Max 
                y = Grid(end, end);
                return;
            end
           
            % Check to see if the point lies on the either of the time 
            % boundaries
           
            i = 1 ; %intialise
            j = 1 ; %intialise
            % k = 0 ; %intialise
            
            if Current_y <= Y_Min
                for i = 1 : size(X, 2)-1 %End points have already been tested
                    if Current_x >= X(1, i ) && Current_x <= X(1,i+1)
                        % Reduces to linear interpolation
                        y = (Current_x - X(1, i )) / (X(1,i+1) - X(1,i )) ...
                            * Grid(i+1, 1) + Grid(i , 1) * ...
                            (1 - (Current_x - X(1,i )) ...
                            / (X(1, i+1) - X(1, i )));
                       return;
                    end
                end
                
            elseif Current_y >= Y_Max
                for i = 1 : size(X, 2) - 1 %End points have already been tested
                    if Current_x >= X(1,i ) && Current_x <= X(1, i+1)
                        
                        y = (Current_x - X(1, i )) / (X(1, i+1) - X(1,i )) ...
                            * Grid(i+1, size(Y, 2)) + Grid(i , size(Y, 2)) * ...
                            (1 - (Current_x - X(1, i )) ...
                            / (X(1,i+1) - X(1,i )));
                       return;
                    end
                end
            end
            
              
            if Current_x <= X_Min
                for i = 1 : size(Y, 2) - 1 %End points have already been tested
                    if Current_y >= Y(1, i ) && Current_y <= Y(1, i+1)
                        
                        y = (Current_y - Y(1, i )) / (Y(1, i+1) - Y(1, i )) ...
                            * Grid(1, i+1) + Grid(1, i ) * ...
                            (1 - (Current_y - Y(1, i ))...
                            / (Y(1, i+1) - Y(1, i )));
                        
                        return;
                    end
                end
            elseif Current_x >= X_Max
                for i = 1 : size(Y, 2) - 1 %End points have already been tested
                    if Current_y >= Y(1, i ) && Current_y <= Y(1, i+1)
                        
                        y = (Current_y - Y(1, i )) / (Y(1, i+1) - Y(1, i ))...
                            * Grid(size(X, 2), i+1) + Grid(size(X, 2), i ) * ...
                            (1 - (Current_y - Y(1, i ))...
                            / (Y(1, i+1) - Y(1, i )));
                        return;
                    end
                end
                end
                
                
                %The remaining case is to interpolate within the grid
                
                %First calculate the indices i & j
                for i = 1 : size(X, 2) - 1 %End points have already been tested
                    if Current_x >= X(1, i ) && Current_x <= X(1, i+1)
                          break % Exit for loop
                    end
                end
                
                for j = 1 : size(Y, 2) - 1 %End points have already been tested
                    if Current_y >= Y(1, j ) && Current_y <= Y(1, j+1) 
                          break % Exit for loop
                    end
                end
                
                
        else
            
            % The following code interpolates within the grid & 
            % extrapolates outside the grid
            
            % Get the X-coordinates   
            
            if Current_x <= X_Min
                i = 1;
            elseif Current_x >= X_Max
                i = size(X, 2)-1 ;  % This allows us to use the previous 
                                % two points to inform us of the gradient
            else
                
                % First calculate the indices i & j
                for i = 1 : size(X, 2) - 1
                    if Current_x >= X(1, i ) && Current_x <= X(1, i+1)
                         break % Exit for loop
                    end
                end
                
            end
            
            
            % Get the Y-coordinates            
            
            if Current_y <= Y_Min
                j = 1;
            elseif Current_y >= Y_Max
                j = size(Y, 2) -1 ;  % This allows us to use the previous 
                                % two points to inform us of the gradient
            else
                
                for j = 1 : size(Y, 2) - 1 
                    if Current_y >= Y(1, j ) && Current_y <= Y(1, j+1) 
                        break
                    end
                end
                
            end
                
                
        end
            
            % Now use interpolation function
            
            X_1 = X(1, i  );
            X_2 = X(1, i+1);
            Y_1 = Y(1, j );
            Y_2 = Y(1, j+1);
            
            F_11 = Grid(i , j );
            F_12 = Grid(i , j+1);
            F_21 = Grid(i+1, j );
            F_22 = Grid(i+1, j+1);
            
            y = obj.BiLinearInterpolation(Current_x, Current_y, X_1, X_2, ...
                Y_1, Y_2, F_11, F_12, F_21, F_22);
            
            return;
            
            
            
    end
    
    
        
    
    end

end


##### SOURCE END #####
--></body></html>