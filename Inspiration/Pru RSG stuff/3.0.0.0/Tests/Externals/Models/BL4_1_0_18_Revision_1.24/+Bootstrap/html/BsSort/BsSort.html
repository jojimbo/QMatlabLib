
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Sort</title><meta name="generator" content="MATLAB 7.11.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-05-24"><meta name="DC.source" content="BsSort.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Sort</h1><!--introduction--><p><b>The class sorts input data series into increasing numerical order by their axis values.</b></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">How to use the class</a></li><li><a href="#4">Properties</a></li><li><a href="#6">List of methods</a></li><li><a href="#9">Details of methods</a></li></ul></div><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">classdef</span> BsSort &lt; handle
</pre><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>How to use the class<a name="3"></a></h2><p>There are two ways to use this class:</p><div><ol><li>To sort a 1 dimensional data series object by its axis values.</li><li>To sort a 2 dimensional data series object by its axis values.</li></ol></div><h2>Properties<a name="4"></a></h2><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    properties

    <span class="keyword">end</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>List of methods<a name="6"></a></h2><p>The class introduces two new methods:</p><div><ol><li><b>[SortDataSeries()|</b> - Function returns a one or two dimensional data series sorted into increasing numerical order by axis values.</li><li><b>[ShellSort2()]|</b> - Function returns a data series sorted in increasing numerical order by either a row or a column but not both.</li></ol></div><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    methods
</pre><pre class="codeinput">     <span class="comment">% Constructor</span>

     <span class="keyword">function</span> obj = BsSort()

     <span class="keyword">end</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeoutput">
ans = 

  Bootstrap.BsSort handle with no properties.
  Package: Bootstrap


</pre><h2>Details of methods<a name="9"></a></h2><p><b>1) <tt>[BsSort()]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Function returns a sorted version of the one or two dimensional <b><tt>DataSeriesIn</tt></b> with the values of the axes in increasing numerical order.</p><p><b><i>Inputs</i></b></p><p><b><tt>[DataSeriesIn]</tt></b> : Data series to be sorted.</p><pre>Data type : double data series</pre><p><b><i>Outputs</i></b></p><p>A sorted version of <b><tt>DataSeriesIn</tt></b> with the values of the axes in increasing numerical order.</p><pre>Data type : double data series</pre><p><b><i>Calculations</i></b></p><p>Depending on whether <b><tt>DataSeriesIn</tt></b> has one or two axes the function <b><tt>ShellSort2()</tt></b> is called once or twice to sort by the one or two axes.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

    <span class="comment">% Functions and Methods</span>

       <span class="keyword">function</span> outputDataSeries = SortDataSeries(obj,DataSeriesIn)

           outputDataSeries = DataSeriesIn.Clone();
           iNumberOfDataSeries = size(DataSeriesIn, 2) ;


           <span class="keyword">for</span> i = 1 :  iNumberOfDataSeries
                inumberOfDates = size(DataSeriesIn(i).dates, 1);
                 iNumberofAxis = size(DataSeriesIn(i).axes, 2);


             <span class="keyword">for</span> j= 1 :  inumberOfDates

                 <span class="keyword">if</span> iNumberofAxis == 1

                     AxisValues1 = cell2mat(DataSeriesIn(i).axes(1).values);

                     Values = DataSeriesIn(i).values{j};
                     <span class="comment">% Sort by 1st Axis</span>

                     sortedData =  obj.ShellSort2<span class="keyword">...</span>
                         ( [AxisValues1 ;  Values] ,2);
                     outputDataSeries(i).axes(1).values = <span class="keyword">...</span>
                         num2cell(sortedData(1,1:end));
                     outputDataSeries(i).values{j} = sortedData(2,1:end);

                 <span class="keyword">elseif</span> iNumberofAxis == 2

                     AxisValues1 = cell2mat(DataSeriesIn(i).axes(1).values);
                     AxisValues2  = cell2mat(DataSeriesIn(i).axes(2).values);
                     Values = DataSeriesIn(i).values{j};
                     <span class="comment">% Sort by 2nd Axis</span>
                     sortedData =  obj.ShellSort2<span class="keyword">...</span>
                         ( [AxisValues2;  Values ] ,2);
                     outputDataSeries(i).axes(2).values = <span class="keyword">...</span>
                         num2cell(sortedData(1, 1:end));
                      <span class="comment">% Sort by 1st Axis</span>
                     sortedData =  obj.ShellSort2<span class="keyword">...</span>
                         ([AxisValues1', sortedData(2:end, 1:end)],1);
                     outputDataSeries(i).axes(1).values = <span class="keyword">...</span>
                         num2cell(sortedData(1:end,1)');
                     outputDataSeries(i).values{j} = sortedData(1:end,2:end);

                 <span class="keyword">end</span>

             <span class="keyword">end</span>
           <span class="keyword">end</span>

       <span class="keyword">end</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><p><b>1) <tt>[ShellSort2()]</tt></b></p><p>""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""</p><p><b><i>Description</i></b></p><p>Using a shell sort algorithm the function returns a version of <b><tt>inputArray</tt></b> which has been sorted into increasing numerical order by one column or one row.</p><p><b><i>Inputs</i></b></p><p><b><tt>[inputArray]</tt></b> : The array to be sorted</p><pre>Data type : double array</pre><p><b><tt>[dimension]</tt></b> : Specifies whether <b><tt>inputArray</tt></b> is to be sorted by the first row (<b><tt>dimension</tt></b><img src="BsSort_eq61876.png" alt="$=1$">) or the first column (<b><tt>dimension</tt></b><img src="BsSort_eq01742.png" alt="$=2$">).</p><pre>Data type : double</pre><p><b><i>Outputs</i></b></p><p>A version of <b><tt>inputArray</tt></b> which has been sorted into increasing numerical order by one column or one row.</p><pre>Data type : double array</pre><p><b><i>Calculations</i></b></p><p>The function sorts <b><tt>inputArray</tt></b> with a shell sort algorithm. Shell sort is a multi-pass algorithm. On each pass elements are compared with elements separated from them by multiples of the increment and sorted within these groups.</p><p>On the next pass the increment size is decreased and so on until, finally the increment is 1. The algorithm uses a multi-pass technique instead of just sorting the whole data set in one go for efficiency reasons.</p><p>If <b><tt>dimension</tt></b><img src="BsSort_eq01742.png" alt="$=2$"> then <b><tt>inputArray</tt></b> is transposed at the start, sorted and then transposed back before it is returned.</p><pre class="codeinput"><span class="comment">%MATLAB CODE</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

        <span class="keyword">function</span> outputArray = ShellSort2(obj,inputArray, dimension)

            <span class="comment">% Step 0 :: Transpose matrix into the required row set-up for</span>
            <span class="comment">% sorting via the main algorithm</span>

            <span class="keyword">if</span> dimension == 1
                <span class="comment">% Sort matrix by the first column</span>
                array = inputArray;
            <span class="keyword">elseif</span> dimension == 2
                <span class="comment">% Sort matrix by the first row</span>
                array = inputArray';
            <span class="keyword">end</span>

            <span class="comment">% Step 1 :: Begin Main Sorting Algorithm</span>

            LRow = 1;
            URow = size(array, 1);

            Temp = zeros( 1, size(array, 2));     <span class="comment">% Allocate storage space</span>
            Increm = 1;

             <span class="keyword">while</span>  Increm  &lt;= (URow - LRow)
                 Increm = 3 * Increm + 1;
             <span class="keyword">end</span>

             Increm = round(Increm / 3);

            <span class="keyword">while</span> (Increm &gt;= LRow)

                <span class="comment">%This is the insertion sort algorithm</span>
                <span class="keyword">for</span> i = (Increm + LRow) : URow

                        Temp(1, :) = array(i, :) ; <span class="comment">% Stores Temp Values</span>

                        j = i  ;
                              <span class="keyword">while</span> array(j - Increm,1) &gt; Temp(1,1)
                                 array(j , :) = array(j- Increm, :);
                                 j = j - Increm;
                                 <span class="keyword">if</span> j &lt;= Increm
                                     <span class="keyword">break</span>
                                 <span class="keyword">end</span> ;
                              <span class="keyword">end</span>
                        array(j  , : ) = Temp;
                <span class="keyword">end</span>

                Increm = round(Increm / 3); <span class="comment">%Reduce size of the increment</span>
            <span class="keyword">end</span>

            <span class="comment">% Step 2 :: Output Result transposing if necessary</span>
             <span class="keyword">if</span> dimension == 1
                <span class="comment">% Sort matrix by the first column</span>
                outputArray = array;
            <span class="keyword">elseif</span> dimension == 2
                <span class="comment">% Sort matrix by the first row</span>
                outputArray = array';
            <span class="keyword">end</span>


            <span class="keyword">return</span>

        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.11.1<br></p></div><!--
##### SOURCE BEGIN #####
%% Sort
% *The class sorts input data series into increasing numerical order by 
% their axis values.*
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef BsSort < handle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% How to use the class
% There are two ways to use this class:
%
% # To sort a 1 dimensional data series object by its axis values.
% # To sort a 2 dimensional data series object by its axis values.
%
%
%% Properties
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    properties
       
    end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% List of methods
% The class introduces two new methods:
%
% # *[SortDataSeries()|* - Function returns a one or two dimensional
% data series sorted into increasing numerical order by axis values.
% # *[ShellSort2()]|* - Function returns a data series sorted in increasing
% numerical order by either a row or a column but not both.
%
%%
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    methods
     % Constructor
     
     function obj = BsSort()
        
     end    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                
%% Details of methods
%
% *1) |[BsSort()]|*
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Function returns a sorted version of the one or two dimensional 
% *|DataSeriesIn|* with the values of the axes in increasing numerical 
% order.
%
% *_Inputs_*
%
% *|[DataSeriesIn]|* : Data series to be sorted.
%
%  Data type : double data series
%
% *_Outputs_*
%
% A sorted version of *|DataSeriesIn|* with the values of the axes in
% increasing numerical order.
% 
%  Data type : double data series 
%
% *_Calculations_*
%
% Depending on whether *|DataSeriesIn|* has one or two axes the function
% *|ShellSort2()|* is called once or twice to sort by the one or two axes.
%
%
%% 
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Functions and Methods   
     
       function outputDataSeries = SortDataSeries(obj,DataSeriesIn)
             
           outputDataSeries = DataSeriesIn.Clone();       
           iNumberOfDataSeries = size(DataSeriesIn, 2) ;
           
           
           for i = 1 :  iNumberOfDataSeries
                inumberOfDates = size(DataSeriesIn(i).dates, 1);
                 iNumberofAxis = size(DataSeriesIn(i).axes, 2);                 
                                  
                 
             for j= 1 :  inumberOfDates
                 
                 if iNumberofAxis == 1 
                     
                     AxisValues1 = cell2mat(DataSeriesIn(i).axes(1).values); 
                     
                     Values = DataSeriesIn(i).values{j};
                     % Sort by 1st Axis                  
                    
                     sortedData =  obj.ShellSort2...
                         ( [AxisValues1 ;  Values] ,2);     
                     outputDataSeries(i).axes(1).values = ...
                         num2cell(sortedData(1,1:end));
                     outputDataSeries(i).values{j} = sortedData(2,1:end);
                     
                 elseif iNumberofAxis == 2
                     
                     AxisValues1 = cell2mat(DataSeriesIn(i).axes(1).values);  
                     AxisValues2  = cell2mat(DataSeriesIn(i).axes(2).values);
                     Values = DataSeriesIn(i).values{j};
                     % Sort by 2nd Axis
                     sortedData =  obj.ShellSort2...
                         ( [AxisValues2;  Values ] ,2);            
                     outputDataSeries(i).axes(2).values = ...
                         num2cell(sortedData(1, 1:end));
                      % Sort by 1st Axis 
                     sortedData =  obj.ShellSort2...
                         ([AxisValues1', sortedData(2:end, 1:end)],1);     
                     outputDataSeries(i).axes(1).values = ...
                         num2cell(sortedData(1:end,1)');
                     outputDataSeries(i).values{j} = sortedData(1:end,2:end);
                                          
                 end     
                 
             end 
           end    
               
       end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%
% *1) |[ShellSort2()]|*
%
% """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
%
% *_Description_*
%
% Using a shell sort algorithm the function returns a version of
% *|inputArray|* which has been sorted into increasing numerical order by 
% one column or one row. 
%
% *_Inputs_*
%
% *|[inputArray]|* : The array to be sorted
%
%  Data type : double array
%
% *|[dimension]|* : Specifies whether *|inputArray|* is to be sorted by the
% first row (*|dimension|*$=1$) or the first column (*|dimension|*$=2$).
%
%  Data type : double
%
% *_Outputs_*
%
% A version of *|inputArray|* which has been sorted into increasing 
% numerical order by one column or one row. 
%
%  Data type : double array
%
% *_Calculations_*
%
% The function sorts *|inputArray|* with a shell sort algorithm. Shell sort
% is a multi-pass algorithm. On each pass elements are compared with 
% elements separated from them by multiples of the increment and sorted 
% within these groups.
% 
% On the next pass the increment size is decreased and so on until, finally
% the increment is 1. The algorithm uses a multi-pass technique instead of
% just sorting the whole data set in one go for efficiency reasons.
%
% If *|dimension|*$=2$ then *|inputArray|* is transposed at the start,
% sorted and then transposed back before it is returned.
%
%
%% 
%MATLAB CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
     
        function outputArray = ShellSort2(obj,inputArray, dimension)

            % Step 0 :: Transpose matrix into the required row set-up for
            % sorting via the main algorithm
            
            if dimension == 1 
                % Sort matrix by the first column
                array = inputArray;
            elseif dimension == 2
                % Sort matrix by the first row
                array = inputArray';
            end     
            
            % Step 1 :: Begin Main Sorting Algorithm
            
            LRow = 1;
            URow = size(array, 1);
            
            Temp = zeros( 1, size(array, 2));     % Allocate storage space       
            Increm = 1;
            
             while  Increm  <= (URow - LRow)
                 Increm = 3 * Increm + 1;
             end
                     
             Increm = round(Increm / 3);
             
            while (Increm >= LRow)
                
                %This is the insertion sort algorithm
                for i = (Increm + LRow) : URow                     
                  
                        Temp(1, :) = array(i, :) ; % Stores Temp Values                                                  
                        
                        j = i  ;    
                              while array(j - Increm,1) > Temp(1,1)                                 
                                 array(j , :) = array(j- Increm, :);
                                 j = j - Increm;
                                 if j <= Increm 
                                     break 
                                 end ;
                              end     
                        array(j  , : ) = Temp;                         
                end
               
                Increm = round(Increm / 3); %Reduce size of the increment
            end
                        
            % Step 2 :: Output Result transposing if necessary
             if dimension == 1 
                % Sort matrix by the first column
                outputArray = array;
            elseif dimension == 2
                % Sort matrix by the first row
                outputArray = array';
            end 
            
           
            return
            
        end
        
        
        
        
        
    end
    
end


##### SOURCE END #####
--></body></html>