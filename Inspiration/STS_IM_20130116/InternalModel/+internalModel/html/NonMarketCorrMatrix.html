
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NonMarketCorrMatrix</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-12-05"><meta name="DC.source" content="NonMarketCorrMatrix.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">NonMarketCorrMatrix</a></li><li><a href="#2">Properties</a></li><li><a href="#3">Methods</a></li><li><a href="#4">NonMarketCorrMatrix <i>constructor</i></a></li><li><a href="#6">lookupBEandRT</a></li></ul></div><h2>NonMarketCorrMatrix<a name="1"></a></h2><p>value class</p><h2>Properties<a name="2"></a></h2><div><ul><li>beTable             <i>cell</i>      conversion table for Base Entities</li><li>correlationMatrix   <i>double</i>    correlation matrix</li><li>headers             <i>cell</i>      correlation matrix headers</li><li>rtTable             <i>cell</i>      conversion table for Risk Types</li></ul></div><h2>Methods<a name="3"></a></h2><div><ul><li><tt>obj = NonMarketCorrMatrix(matrixFile, beMapFile, rtMapFile)</tt>    % <i>constructor</i></li><li><tt>[idx, msg] = lookupBEandRT(obj, baseEntity, riskType)</tt></li></ul></div><h2>NonMarketCorrMatrix <i>constructor</i><a name="4"></a></h2><p><tt>obj = NonMarketCorrMatrix(matrixFile, beMapFile, rtMapFile)</tt></p><p>Input:</p><div><ul><li>matrixFile  <i>char</i></li><li>beMapFile   <i>char</i></li><li>rtMapFile   <i>char</i></li></ul></div><h2>lookupBEandRT<a name="6"></a></h2><p><tt>[idx, msg] = lookupBEandRT(obj, baseEntity, riskType)</tt></p><p>Inputs:</p><div><ul><li><tt>NMR</tt>       <i>NonMarketRisk</i></li></ul></div><p>Outputs:</p><div><ul><li><tt>idx</tt>       <i>logical</i></li><li><tt>msg</tt>       <i>char</i></li></ul></div><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% NonMarketCorrMatrix 
% value class

classdef NonMarketCorrMatrix

    %% Properties    
    % * beTable             _cell_      conversion table for Base Entities
    % * correlationMatrix   _double_    correlation matrix
    % * headers             _cell_      correlation matrix headers
    % * rtTable             _cell_      conversion table for Risk Types

    properties
        beTable
        correlationMatrix
        headers
        rtTable
    end


    %% Methods    
    % * |obj = NonMarketCorrMatrix(matrixFile, beMapFile, rtMapFile)|    % _constructor_
    % * |[idx, msg] = lookupBEandRT(obj, baseEntity, riskType)|

    methods

        function obj = NonMarketCorrMatrix(matrixFile, beMapFile, rtMapFile)
            %% NonMarketCorrMatrix _constructor_
            % |obj = NonMarketCorrMatrix(matrixFile, beMapFile, rtMapFile)|
            % 
            % Input: 
            % 
            % * matrixFile  _char_
            % * beMapFile   _char_
            % * rtMapFile   _char_

            % Open matrixFile
            [fidMD1, errMsg] = fopen(matrixFile, 'r');

            if fidMD1 < 0
                error('ing:FileNotFound', errMsg);
            end

            % Second line of the file is needed to extract the number of
            % entries. The second line holds numbers corresponding to Base
            % Entities (BE)

            % Ignore first line
            fgetl(fidMD1);

            % Read second line
            lin     = fgetl(fidMD1);
            commas  = strfind(lin, ',');
            fclose(fidMD1);

            % matrixFile is build as ,,,x,y,z,aa,bb so nr of entries needs
            % to be increased by 1
            nrEntries = length(commas) + 1;

            % open matrixFile again
            [fidMD2, errMsg] = fopen(matrixFile, 'r');

            if fidMD2 < 0
                error('ing:FileNotFound', errMsg);
            end

            % Generate format
            % first four columns should be ignored, other elements are
            % doubles / floats
            matFormat = '%s %*s %s %*s';

            for iEntries = 1:nrEntries-4
                matFormat = strcat(matFormat, ' %f');
            end

            % Read matrixFile in as a cell matrix of strings (char-array)
            % row/column #5 and further contain actual matrixData
            headerAndMatrix = textscan(fidMD2, matFormat, 'delimiter', ',', ...
                                       'HeaderLines', 4, 'CollectOutput', true);

            fclose(fidMD2);
            obj.correlationMatrix   = headerAndMatrix{2};
            obj.headers             = strtrim(headerAndMatrix{1});

            % Base Entity names are not always filled for all rows, in
            % order to have nicer lookup this should be done
            currBE = '';

            for iHeader = 1:length(obj.headers(:, 1))

                if ~isempty(obj.headers{iHeader, 1}) && ~strcmp(obj.headers{iHeader, 1}, currBE)
                    % New header or same header
                    currBE = strtrim(obj.headers{iHeader, 1});

                else
                    % Header to be filled with previous (and same) base entity
                    obj.headers{iHeader, 1} = currBE;
                end
            end

            % Read base entity mapping table            
            beTableCll          = internalModel.Utilities.csvreadCell(beMapFile);
            rawBeTable          = strtrim(beTableCll);

            % Convert such that abbrevation is always in second column
            convBeTable         = internalModel.Converter.remapBEtable(rawBeTable);
            obj.beTable         = convBeTable;

            % Read risk type mapping table
            rtTableCll          = internalModel.Utilities.csvreadCell(rtMapFile);
            rawRtTable          = strtrim(rtTableCll);

            % Convert such that abbrevation is always in second column
            convRtTable         = internalModel.Converter.remapRTtable(rawRtTable);
            obj.rtTable         = convRtTable;

        end


        function [idx, msg] = lookupBEandRT(obj, NMR)
            %% lookupBEandRT
            % |[idx, msg] = lookupBEandRT(obj, baseEntity, riskType)|
            % 
            % Inputs:
            % 
            % * |NMR|       _NonMarketRisk_
            % 
            % Outputs:
            % 
            % * |idx|       _logical_
            % * |msg|       _char_
            idx        = [];
            msg        = '';
            baseEntity = NMR.BaseEntity;
            riskType   = NMR.RiskType;

            if      isempty(obj.beTable) || ...
                    isempty(obj.rtTable) || ...
                    (nargin < 2)         || ...
                    isempty(baseEntity)  || ...
                    isempty(riskType)

                return
            end

            % Find indices in conversion tables
            idxBE   = strcmp(baseEntity, obj.beTable(:, 2));
            idxRT   = strcmp(riskType, obj.rtTable(:, 2));

            % Convert baseEntity and riskType
            baseEntityConv  = obj.beTable{idxBE, 1};
            riskTypeConv    = obj.rtTable{idxRT, 1};

            % Find location in header
            idxBEinHeader   = strcmp(baseEntityConv, obj.headers(:, 1));
            idxRTinHeader   = strcmp(riskTypeConv, obj.headers(:, 2));
            idx             = idxBEinHeader & idxRTinHeader;

            % Output check, a single entry is wanted, warn user when
            % multiple or none entries are found
            sumidx = sum(idx);

            if sumidx > 1
                msg = 'Multiple entries found';

            elseif sumidx == 0
                msg = 'No entries found';
            end

        end

    end

end

##### SOURCE END #####
--></body></html>